开始学C语言前,我们要**先了解C语言中的基本数据类型**.在C语言中,有着非常丰富的数据类型,因此它很适合编写数据库.
# 目录
1. [[#引言]]
2. [[#一、变量|认识变量]]
3. [[#二、sizeof计算字节长度]]
4. [[#三、整形，浮点型，字符型]]
	- [[#整形类型]] 
		- [[#取值大小与signed和unsigned的关系]]
	- [[#浮点型]]
		- [[#float和double的使用]] 
	- [[#字符型]]
		- [[#^a85ad7|ASCLL码的运算]]
# 引言


C语言中的数据类型分为以下几类
![[70c0b71dbe6ece65d285fb141907037b.jpg]]
首先我们要**先了解变量是什么,然后再进入基本数据类型的认识**

# 一、变量

C语言中通常会进行下列编写
```C
int a = 0; //int为变量类型  a为变量名
```
C语言中，变量是用来存放a的值，将0赋值给变量a时，**因此a = 0会被存入int类型中**

## 先定义，后初始化

**变量的类型决定占用内存的大小**，**int类型占用4个字节**（[[#二、sizeof计算字节长度|跳转至sizeof]]），换成**char类型**只需要给你分配**一个字节**就可以了，没必要分配过多字节乃至更多的储存空间
```C
int a = 0; //占用4个字节
//int类型   a变量
char ch = 'a'; //占用1个字节
//char类型  ch变量
```

在VS编译器中，**C语言中没有经过初始化赋值这是可以不能使用的**
```C
#include<stdio.h>
{
    int b; //只初始化，并没有赋值
    printf("%d", b);
    return 0;
}
```

![[屏幕截图 2025-09-27 125336.png]]

但这是很危险的，不建议这样做。大部分人认为b = 0，但不是这样的。只初始化**系统会随机分配个垃圾数据给b**

# 二、sizeof计算字节长度

为什么要把sizeof放在这边讲，因为下面讲解中会涉及到类型所占字符大小。在需要知道确切大小时，总是使用**sizeof运算符来获取当前系统的实际大小**
**语法：sizeof(类型/变量)**；
```C
#include<stdio.h>

int main()
{
	short s = 0;
	printf("%zd\n",sizeof(s));//占用2字节
	printf("%zd\n",sizeof(short));//占用2字节
	
	int a = 0;
	printf("%zd\n",sizeof(a));//占用4字节
	printf("%zd\n",sizeof(int));//占用4字节
	

	float f = 3.14f;
	printf("%zd\n", sizeof(f));//占用4字节
	printf("%zd\n",sizeof(float));//占用4字节
	

	double d = 3.1415926;
	printf("%zd\n", sizeof(d));//占用8字节
	printf("%zd\n",sizeof(double));//占用8字节
	

	return 0;
}
```

后面我会单独讲解占位符的基本定义和工作原理，这里先挖个坑
# 三、整形，浮点型，字符型

## 整形类型

整形分为**短整型short占2字节，整形int占4字节，长整型long占8字节，长长整形long long占16字节**.以上的内存均可通过sizeof字符计算出来

总结如下列图表：

| 类型  | short | int | long | long long |
| --- | ----- | --- | ---- | --------- |
| 字节  | 2     | 4   | 8    | 16        |
## 取值大小与signed和unsigned的关系
对于上面的signed与unsigned只需要大概了解下，后面会详细出一类讲解，这里先挖个坑

short类型取值范围为-32768~32767
**signed**代表**有符号**，包括**正数和负数和0**；
**unsigned**代表**无符号**，包括**正数和0**
```C
signed short a = 0; //取值范围-32768~32767
unsigned short b = 0; //取值范围0~65535
```
可看到在unsigned下的short，会将多余的负数补给正数使用

signed、unsigned也可以修饰char，long，double类型,取值也与上列相同
```C
unsigned char c1 = 10;
signed char c2 = -10;
```

## 浮点型

浮点型包括单精度float与双精度double，正如前面所说单精度精确，双精度更精确
```C
float a = 3.14159f;
printf("%f",a);//a = 3.14159

double b = 3.14159;
printf("%lf",b);//b = 3.14159
```

### 占用的字节(基本特征)

同样通过sizeof字符来计算占用内存大小
```C
printf("%zd\n"sizeof(float));//4
printf("%zd\n"sizeof(double));//8
```
总结如下列图表：

| 类型  | float | double |
| --- | ----- | ------ |
| 字节  | 4     | 8      |

### float和double的使用

- 切记给使用float类型赋值时，值的结尾必须加上如a = 3.14159f，不然编译器会默认为double类型
- 使用**float和double类型时可以控制小数点**
```C
float a = 1;
printf("a = %.1f",a);//a = 1.0

float a = 1;
printf("a = %.2f",a);//a = 2.0
```
后期会单独讲解一期如何控制小数点，这里再挖个坑
## 字符型

### 字符型的基本特征

用上面说过的sizeof来计算字符类型的内存
```C
char a = 'A';
//字符型占用内存
printf("char类型大小:%zu字节\n",sizeof(char));//一个字节
printf("char类型大小:%zu字节\n",sizeof('A'));//一个字节
```

### 字符型范围

通常**char类型的范围在-128~127 (有符号) 或 0~255(无符号)之间**，那我们可以这样表示 ^a85ad7
```C
#include<stdio.h>

int main()
{
	char ch1 = 65;
	char ch2 = 'A';
	printf("ch1 = %c\n", ch1);
	printf("ch2 = %c\n", ch2);

	return 0;
}
```

输出结果如下:
![[屏幕截图 2025-09-28 000644.png]]

那么为什么在char类型中输入一个整数65，会得到字符A呢？因为**在C语言中，每个字符都有对应的ASCLL码值**![[Pasted image 20250928001657.png]]
可在以下网址上查询：
- [cplusplus.com - C++资源网络](https://legacy.cplusplus.com/)
- [cppreference.cn - C++参考手册](https://cppreference.cn/w/)

所以我们在char类型中输入并打印65，输出的却是A的原因，**是char类型将65转化成字符中所对应的ASCLL码值**，那么用整数加减也会得到相应的ASCLL码值吗？

![[QQ20250928-125152.png]]
输出结果为：
![[QQ20250928-125123.png]]
可以看出**随着char类型中的变量改变，所得到的字符也会改变**，当超出ASCLL码值时，编译器将识别不出来